
# 常用命令
    netstat -anp | grep redis
        -a：显示所有连接和监听端口，包括正在使用的和未使用的端口。
        -n：使用数字格式显示地址和端口号，而不进行反向域名解析。
        -p：显示与每个连接或监听端口相关的进程的PID和进程名称。
    telnet <hostname or IP> <port>


# gdb 调试
    ps -u                       # 查看进程
    gdb attach pid              # 挂载进程
    info threads                # 查看线程
    thread 2                    # 切换线程
    bt                          # 查看调用栈


    gdb ChatServer              # 进入gdb调试
    break chatservice.cpp:41    # 设置断点
    run                         # 运行程序（如果有参数，需要在run后加上，如 run 127.0.0.1 6000）


# mysql grant
    ## 给予wly 操作chat数据库的所有权限，并且wly可以从任何地址登录
    GRANT ALL PRIVILEGES ON chat.* TO 'wly'@'%';

    ## 设置root用户可以从任何地址登录的
    mysql -uroot -p                                # root用户登录msyql   
    use mysql;                                     # 使用mysql数据库
    show tables;                                   # 查看mysql数据库的数据表
    select host from user;                         # 查看user表的host
    update user set host ='%' where user ='root';  # 修改root用户访问权限，可以从网络访问
    flush privileges;              # 刷新用户权限（本质上是将用户信息和权限信息提取到内存中）


# mysql 备份和恢复数据库
    mysqldump -u root -p chat > chat_backup.sql
    mysql -u root -p chat < chat_backup.sql


# redis 发布-订阅相关命令（redis本质上是一个存储键值对的缓存数据库）
    # redis安装
    sudo apt-get install redis-server           # 安装redis（安装完成后，自动启动）
    netstat -anp | grep redis                   # 查看redis进程
    
    # 初识redis命令
    redis-cli                   # 登录redis
    set "abc" "hello world"     # 设置键值对
    get "agc"                   # 获取键值对
    subscribe 13                # 订阅13通道消息（一般订阅这个通道id取用户id）
    publish 13 "hello world"    # 发布13通道消息


# 问题记录
    # 为什么用redis作为跨服务器通信的组件？为什么各个server不能相互直接进行通信呢？
        减少资源消耗。server和server之间通信会大大增加资源消耗（server充当了client的角色）。
        便于集群扩充。增加服务器节点时，新服务器只需要和redis进行通信，不需要知道其他服务器的ip地址和端口号。

    # 除了redis还有哪些服务器中间件？
        kafka、zeromq、rabbitmq、rocketmq...

    # redis的发布订阅功能存在哪些缺陷？
        redis运行不稳定，比如redis消息积累快，消耗慢，会导致进程消耗内存增加，被系统杀掉

    # 网络阻塞严重，ChatServer如何感知客户端在线？
        心跳机制：
            心跳机制是一种网络通信中的维持活动状态的策略，主要用于检测连接双方是否仍然在线以及保持通道的活跃性。在TCP/IP协议栈中，虽然TCP协议自身提供了保活机制（Keepalive），但其默认配置是作用于传输层（应用层死锁时，传输层依然可以通信），并不适用于业务场景，因此在许多实际的网络应用中，开发人员会设计更为灵活和及时的心跳机制。
        工作原理：
            客户端/服务端定时发送心跳包：
                发送方（可以是客户端或服务端）会在设定的时间间隔（如每隔N秒）向对方发送一个特定格式的“心跳包”，这个包通常包含非常小的数据量，有时候甚至是空包。
            接收方响应心跳包：
                接收方收到心跳包后，会回复一个确认包，表明自己仍然在线并能正常接收和处理数据。
            超时判断与连接关闭：
                如果发送方在预设的一段时间（例如心跳周期的几倍）内未收到接收方的回应，就可以推断连接可能已断开，此时发送方会采取行动，比如关闭连接、重新建立连接或者执行其他恢复策略。
        这种机制广泛应用于长连接场景，如游戏服务器、IM即时通讯系统、WebSocket连接、远程监控系统等，以确保即使在网络条件不稳定或对方节点异常的情况下，也能快速检测到连接失效，并作出相应的应对措施，从而避免资源浪费和提高系统的健壮性。

        listen socket 8080    通用业务处理
        UDP socket 8080       心跳检测
        connect成功的客户端client分配一个心跳计数。
        server启动一个心跳计数器，超时1s把所有账号的心跳计数+1，收到客户端消息则该客户端心跳计数-1（客户端每隔1s发送心跳包），如果心跳计数超过一定值，则认为客户端掉线，拆除这个client连接和其他资源。
        userid:12   heartbeatcnt:2
        userid:13   heartbeatcnt:5

    # 如何进行历史消息存储？
        将消息存储在本地文件中，或者数据库中

    # 怎么保证消息的可靠性传输？
        # 为什么tcp的消息确认机制不能保证消息可靠传输？
            TCP（Transmission Control Protocol）协议虽然提供了连接建立、数据分段、排序以及确认重传等机制，它能保证数据在网络层的传输可靠性，即每个TCP包都会被接收方确认并且丢失的数据包会被重传，但是TCP本身并不能解决网络环境或应用层的问题，比如网络环境错误、应用级别处理错误、bug等。
        # 怎么保证消息的可靠性传输？
            业务层模拟TCP重传机制，实现消息确认机制、重试机制

    # 数据明文传输的安全问题
        # 对称加密（Symmetric Cryptography）
            特点：加密和解密使用同一把密钥。因为只有一个密钥，所以这个密钥需要在通讯双方间安全地交换或共享。
                  优点在于计算效率高，加密和解密速度非常快，适合加密大量数据。
                  缺点是密钥管理复杂，一旦密钥泄露，则加密的信息将不再安全（因为加密和解密的密钥相同）。
            举例：AES加解密算法。
        # 非对称加密（Asymmetric Cryptography）
            特点：使用一对密钥，即公钥和私钥。公钥可以公开给任何人，用于加密数据；私钥则由所有者秘密保存，用于解密数据。任何人都可以用公钥对信息进行加密，但只有对应私钥的所有者能解密。
                  优点在于密钥管理简单，密钥泄露不会导致数据泄露。
                  缺点是计算量较大，加密和解密过程较慢。
            举例：RSA加解密算法。
        # 在实践中，通常结合两者的优势：
            服务端和客户端tcp三次握手链接成功之后，使用非对称加密交换一个临时的对称密钥(这个密钥被人非法获取了也无法解密（因为没有非对称加密算法的私钥，只有对称加密算法的私钥的人才可以解密得到该临时的对称密钥），之后利用该密钥进行大量的数据交换，这种方式既保证了数据传输的安全性，又兼顾了效率。
            # 注意点：
                client1 会存储多个临时对称密钥，比如和client2通信需要使用和client2通信的临时对称密钥，那么client1如何找到client2的临时对称密钥呢？这里我们传输信息时，可以不对用户id进行加密，然后根据这个id找到对应的临时对称密钥。

    # 为什么聊天服务器需要设计成 长连接？
        B/S结构是典型的短连接服务模式，只能是浏览器主动请求，服务器被动响应。
        然而，该项目是客户端1给服务端发送消息，服务端给客户端2发送消息，服务端既要响应也要发送消息，所以需要设计成长连接。

    # 客户端消息如何按时间顺序显示？
        由于消息在发送时，消息的网络路由可能不同，导致较早的消息晚到达。
        解决方案1（有问题）：给消息增加时间戳。
            client1：                 ->                            server            ->            client2：
            你在吗？             2019-01-01 10:00:00                   ->                           你下午有什么打算？    2019-01-01 10:01:00
            你下午有什么打算？    2019-01-01 10:01:00                   ->                           下午去打球？         2019-01-01 10:02:00                   
            下午去打球？         2019-01-01 10:02:00                   ->             （该消息阻拥堵）你在吗？             2019-01-01 10:00:00
            # 该方法只能在一定时间内比较时间戳，比如在客户端排序了“你下午有什么打算？” “下午去打球？”，然而此时的“你在么？”可能还没有到达，所以无法比较时间戳，无法保证消息按时间顺序显示。
        解决方案2：每个消息都添加一个序列号seq = 0 1 2 3 4 5 6 7 8 9。
            client1：(维护了client1发送的所有消息序号)  ->      server  ->           client2：(维护了client2接受到的client1发送消息的序列号) 
            你在吗？          seq=0                   ->                            你下午有什么打算？ seq=1  (client2收到seq=0的消息才会发送，此时seq=1，会缓存到本地)
            你下午有什么打算？ seq=1                   ->                            下午去打球？      seq=2   (client2收到seq=0的消息才会发送，此时seq=2，会缓存到本地)
            下午去打球？      seq=2                   ->                             你在吗？          seq=0     
        使用序列号的方式除了可以保证消息顺序显示，还可以实现其他功能，比如：消息根据序列号撤回消息、删除消息、消息撤回通知、消息数量通知等。



